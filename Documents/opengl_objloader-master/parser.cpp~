
#include <stdio.h>
#include <GL/gl.h>
#include <GL/glut.h>
#include <vector>
#include <iostream>

struct fv2{
	float x,y;
};

struct fv3{
	float x,y,z;
};

struct iv3{
	int x,y,z;
}

std::vector<fv3> vertex;
std::vector<fv2> tcoord;
std::vector<fv3> normal;
std::vector<fv3> tangent;
std::vector<fv3> bitangent;
std::vector<std::vector<iv3>> face;

bool loadOBJ(const char* path){

	std::vector< unsigned int > vi,ti,ni;
	std::vector<fv3> tv;
	std::vector<fv2> tt;
	std::vector<fv3> tn;
	std::vector<fv3> ttan;
	std::vector<fv3> tbitan;

	FILE * file = fopen(path, "r");
	if(file==NULL){
	  printf("cannot open the file!\n");
	}
	while(1){
	char header[128];
	int res = fscanf(file, "%s", header);
	if(res==EOF)break;
	}	
	//v
	if(strcmp(header,"v")==0){
	fv3 v;
	fscanf(file, "%f %f %f\n", &v.x, &v.y, &v.z);
	tv.push_back(v);
	//vt
	}else if(strcmp(header, "vt")==0){
	fv2 t;
	fscanf(file, "%f %f\n", &t.x, &t.y);
	tt.push_back(t);
	//vn
	}else if(strcmp(header,"vn")==0){
	fv3 n;
	fscanf(file, "%f %f %f\n", &n.x, &n.y, &n.z);
	tn.push_back(n);
	//vx
	}else if(strcmp(header,"vx")==0){
	fv3 vx;
	fscanf(file, "%f %f %f\n", &vx.x, &vx.y, &vx.z);
	ttan.push_back(vx);
	//vy
	}else if(strcmp(header,"vy")==0){
	fv3 vy;
	fscanf(file, "%f %f %f\n", &vy.x, &vy.y, &vy.z);
	tbitan.push_back(vy);
	//f
	}else if(strcmp(header,"f")==0){
	std::string v1,v2,v3,v4;
	unsigned int vertexIndex[3],tcoordIndex[3],normalIndex[3];
	int checkNum = fscanf(file, 
	"%d/%d/%d %d/%d/%d %d/%d/%d %d/%d/%d\n", 
	&vertexIndex[0],&tcoordIndex[0])
	fv3 n;
	fscanf(file, "%f %f %f\n", &v.x, &v.y, &v.z);
	tv.push_back(v);
	}
}

void setup_the_viewvol()
{
struct v3 eye;
struct v3 view;
struct v3 up;

glEnable(GL_DEPTH_TEST);

/* specify size and shape of view volume */
glMatrixMode(GL_PROJECTION);
glLoadIdentity();
gluPerspective(45.0,1.0,0.1,20.0);

/* specify position for view volume */
glMatrixMode(GL_MODELVIEW);
glLoadIdentity();

eye.x = 2.0; eye.y = 2.0; eye.z = 2.0;
view.x = 0.0; view.y = 0.0; view.z = 0.0;
up.x = 0.0; up.y = 1.0; up.z = 0.0;

gluLookAt(eye.x,eye.y,eye.z,view.x,view.y,view.z,up.x,up.y,up.z);
}

// downside: must specify 24 vertices and 24 normals
// with VBOs, all the data must go in one giant buffer
GLfloat vertices[] = {
0.0,0.0,0.0, 0.0,1.0,0.0, 1.0,1.0,0.0, 1.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,1.0,
1.0,0.0,1.0, 1.0,0.0,0.0, 0.0,0.0,0.0, 0.0,0.0,1.0, 0.0,1.0,1.0, 0.0,1.0,0.0,
0.0,0.0,1.0, 0.0,1.0,1.0, 1.0,1.0,1.0, 1.0,0.0,1.0, 0.0,1.0,0.0, 0.0,1.0,1.0,
1.0,1.0,1.0, 1.0,1.0,0.0, 1.0,0.0,0.0, 1.0,0.0,1.0, 1.0,1.0,1.0, 1.0,1.0,0.0,
// normals[] = 
0.0,0.0,-1.0, 0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,-1.0,0.0,0.0,-1.0,0.0,
0.0,-1.0,0.0, 0.0,-1.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,-1.0,0.0,0.0,
0.0,0.0,1.0, 0.0,0.0,1.0, 0.0,0.0,1.0, 0.0,0.0,1.0, 0.0,1.0,0.0, 0.0,1.0,0.0,
0.0,1.0,0.0, 0.0,1.0,0.0, 1.0,0.0,0.0, 1.0,0.0,0.0, 1.0,0.0,0.0, 1.0,0.0,0.0,
};

void draw_stuff()
{
glClear(GL_COLOR_BUFFER_BIT|GL_DEPTH_BUFFER_BIT);
glDrawArrays(GL_QUADS,0,24);
glutSwapBuffers();
}

void update()
{
usleep(10000);
glTranslatef(0.5,0.0,0.5);
glRotatef(1.0,0.0,1.0,0.0);
glTranslatef(-0.5,0.0,-0.5);
glutPostRedisplay();
}

void do_lights()
{
/* white light */
float light0_ambient[] = { 0.0, 0.0, 0.0, 0.0 };
float light0_diffuse[] = { 1.0, 1.0, 1.0, 0.0 };
float light0_specular[] = { 1.0, 1.0, 1.0, 0.0 };
float light0_position[] = { 1.5, 2.0, 2.0, 1.0 };
float light0_direction[] = { -1.5, -2.0, -2.0, 1.0};

/* turn off scene default ambient */
glLightModelfv(GL_LIGHT_MODEL_AMBIENT,light0_ambient);

/* make specular correct for spots */
glLightModeli(GL_LIGHT_MODEL_LOCAL_VIEWER,1);

glLightfv(GL_LIGHT0,GL_AMBIENT,light0_ambient);
glLightfv(GL_LIGHT0,GL_DIFFUSE,light0_diffuse);
glLightfv(GL_LIGHT0,GL_SPECULAR,light0_specular);
glLightf(GL_LIGHT0,GL_SPOT_EXPONENT,1.0);
glLightf(GL_LIGHT0,GL_SPOT_CUTOFF,180.0);
glLightf(GL_LIGHT0,GL_CONSTANT_ATTENUATION,0.5);
glLightf(GL_LIGHT0,GL_LINEAR_ATTENUATION,0.1);
glLightf(GL_LIGHT0,GL_QUADRATIC_ATTENUATION,0.01);
glLightfv(GL_LIGHT0,GL_POSITION,light0_position);
glLightfv(GL_LIGHT0,GL_SPOT_DIRECTION,light0_direction);

glEnable(GL_LIGHTING);
glEnable(GL_LIGHT0);
}

void do_material()
{
float mat_ambient[] = {0.0,0.0,0.0,1.0};
float mat_diffuse[] = {0.9,0.9,0.1,1.0};
float mat_specular[] = {1.0,1.0,1.0,1.0};
float mat_shininess[] = {2.0};

glMaterialfv(GL_FRONT,GL_AMBIENT,mat_ambient);
glMaterialfv(GL_FRONT,GL_DIFFUSE,mat_diffuse);
glMaterialfv(GL_FRONT,GL_SPECULAR,mat_specular);
glMaterialfv(GL_FRONT,GL_SHININESS,mat_shininess);
}

int mybuf = 1;

void initOGL(int argc, char **argv)
{
glutInit(&argc,argv);
glutInitDisplayMode(GLUT_RGBA|GLUT_DEPTH|GLUT_DOUBLE);
glutInitWindowSize(512,512);
glutInitWindowPosition(100,50);
glutCreateWindow("my_cool_cube");
setup_the_viewvol();
do_lights();
do_material();
glBindBuffer(GL_ARRAY_BUFFER,mybuf);
glBufferData(GL_ARRAY_BUFFER,sizeof(vertices),vertices,GL_STATIC_DRAW);
// When using VBOs, the final arg is a byte offset in buffer, not the address,
// but gl<whatever>Pointer still expects an address type, hence the NULL.
glVertexPointer(3,GL_FLOAT,3*sizeof(GLfloat),NULL+0);
glNormalPointer(GL_FLOAT,3*sizeof(GLfloat),NULL+3*24*sizeof(GLfloat));
glEnableClientState(GL_VERTEX_ARRAY);
glEnableClientState(GL_NORMAL_ARRAY);
/* gray background */
glClearColor(0.35,0.35,0.35,0.0);
}

void getout(unsigned char key, int x, int y)
{
switch(key) {
        case 'q':               
                glDeleteBuffers(1,&mybuf);
                exit(1);
        default:
                break;
    }
}

int main(int argc, char **argv)
{
initOGL(argc,argv);
glutDisplayFunc(draw_stuff);
glutIdleFunc(update);
glutKeyboardFunc(getout);
glutMainLoop();
return 0;
}
